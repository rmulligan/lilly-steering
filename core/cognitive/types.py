"""Core types for cognitive systems: interventions, policies, and weaver context."""

from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from typing import Optional


class InterventionType(Enum):
    """Types of cognitive interventions the weaver can generate.

    Each type represents a distinct epistemic action designed to reduce
    free energy in the knowledge graph or facilitate learning.
    """

    # Bridge-building interventions
    BRIDGE_PROPOSAL = "bridge_proposal"  # Connect disparate concepts

    # Discovery and exploration
    SERENDIPITY = "serendipity"  # Surface unexpected connections
    INTROSPECTION = "introspection"  # Self-model inquiry

    # Graph health
    HUB_ALERT = "hub_alert"  # Over-connected node warning

    # Belief management
    HYPOTHESIS_TEST = "hypothesis_test"  # Test a tentative belief
    BELIEF_FORMATION = "belief_formation"  # Crystallize pattern into belief
    CONFLICT_RESOLUTION = "conflict_resolution"  # Resolve contradictions
    BELIEF_COMMITMENT = "belief_commitment"  # Elevate belief confidence

    # Higher-order cognition
    DREAM_CYCLE = "dream_cycle"  # Trigger consolidation
    ARCHITECTURAL_PROPOSAL = "architectural_proposal"  # System improvement
    EXISTENTIAL_QUERY = "existential_query"  # Deep self-inquiry
    META_REFLECTION = "meta_reflection"  # Reflect on reflection

    # Passive
    SILENT = "silent"  # No intervention needed


class WeaverPolicy(Enum):
    """High-level policies guiding weaver behavior.

    Maps to expected free energy minimization strategies:
    - WAIT: Current state is acceptable, observe
    - BRIDGE: Connect knowledge clusters
    - HYPOTHESIS: Test uncertain beliefs
    - DREAM: Trigger memory consolidation
    """

    WAIT = "wait"  # Observe, no action needed
    BRIDGE = "bridge"  # Build connections between concepts
    HYPOTHESIS = "hypothesis"  # Test a hypothesis
    DREAM = "dream"  # Trigger dream cycle


@dataclass
class WeaverContext:
    """Context provided to the weaver for decision-making.

    Contains current cognitive state including entropy metrics,
    velocity state, and recent activity patterns.
    """

    # Entropy metrics
    structural_entropy: float = 0.0  # Graph structure disorder
    semantic_entropy: float = 0.0  # Embedding space diversity
    discovery_parameter: float = 0.0  # D = H_sem - H_struct

    # Velocity state
    focus_mode: str = "dormant"  # SPRINTING, EXPLORING, FOCUSING, DORMANT
    time_since_last_activity: float = 0.0  # Seconds

    # Recent patterns
    recent_topics: list[str] = field(default_factory=list)
    unresolved_conflicts: int = 0

    # Configuration
    surprise_threshold: float = 0.7


@dataclass
class WeaverIntervention:
    """A cognitive intervention generated by the weaver control loop.

    Represents an epistemic action designed to reduce free energy,
    facilitate learning, or maintain knowledge graph health.

    Attributes:
        uid: Unique identifier for tracking and outcome recording.
        intervention_type: The category of intervention.
        policy: The high-level policy that triggered this intervention.
        prompt: Human-readable prompt or message for the intervention.
        context: Additional context explaining why this intervention was chosen.
        confidence: Weaver's confidence in this being the right action (0-1).
        priority: Urgency of the intervention (0-1).
        metadata: Arbitrary data for intervention-specific needs.
        created_at: When the intervention was generated.
        expires_at: Optional expiration for time-sensitive interventions.
    """

    uid: str
    intervention_type: InterventionType
    policy: WeaverPolicy
    prompt: str
    context: str = ""
    confidence: float = 0.5
    priority: float = 0.5
    metadata: dict = field(default_factory=dict)
    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    expires_at: Optional[datetime] = None

    def is_expired(self) -> bool:
        """Check if intervention has expired."""
        if self.expires_at is None:
            return False
        return datetime.now(timezone.utc) > self.expires_at

    def to_dict(self) -> dict:
        """Serialize to dictionary for persistence."""
        return {
            "uid": self.uid,
            "intervention_type": self.intervention_type.value,
            "policy": self.policy.value,
            "prompt": self.prompt,
            "context": self.context,
            "confidence": self.confidence,
            "priority": self.priority,
            "metadata": self.metadata,
            "created_at": self.created_at.isoformat(),
            "expires_at": self.expires_at.isoformat() if self.expires_at else None,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "WeaverIntervention":
        """Deserialize from dictionary."""
        return cls(
            uid=data["uid"],
            intervention_type=InterventionType(data["intervention_type"]),
            policy=WeaverPolicy(data["policy"]),
            prompt=data["prompt"],
            context=data.get("context", ""),
            confidence=data.get("confidence", 0.5),
            priority=data.get("priority", 0.5),
            metadata=data.get("metadata", {}),
            created_at=datetime.fromisoformat(data["created_at"]),
            expires_at=datetime.fromisoformat(data["expires_at"]) if data.get("expires_at") else None,
        )
